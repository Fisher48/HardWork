#### Задание 3: Думаем на уровне дизайна.  
Для данного задания требовалось написать несколько сотен строк рабочего кода по TDD.
Так как я пока не работаю в разработке, я взял за основу мой текущий пет-проект, над которым я работаю.
Это интернет-магазин инструментов. Естественно изначально я его реализовывал не по методике TDD, а сразу писал код.
Сейчас в нем есть уже Категории (Category) и Товары (Product). К ним тесты я уже писал после реализации.
Сама разработка идет не так быстро потому-что ошибки возникают чаще чем если я бы начал использовать TDD, на чем я убедился реализовывая Корзину (Cart).

И вот в рамках 1 части я начал с модели Корзина (Cart) и начал писать по TDD сначала тесты, а уже потом реализацию.
Это для меня сложный подход, который требует обратного мышления. И мне необходимо представлять что должен делать код, который еще не написан.
Начинается все с малого и я начал писать простой тест создания пустой корзины, и так далее по нарастающей. 
Тест -> Реализация -> Рефакторинг и так по кругу.
Затем тест добавления товара в корзину, удаления, изменение кол-ва товара при добавлении того же товара, какие-то пограничные случаи, когда удалять из корзины него
или добавлять не существующий товар. Все получается как спецификация к коду, если обратить внимание на название тестов.
Они указывают, как должен работать код в определенных случаях.
После каждого теста я добавлял реализацию, было не так просто, но у меня получалось и наконец у меня были готовы тесты по Корзине
и реализованы сущности с сервисами и репозиториями. И они все уже проходили как зеленые т.е корректные. 

````java
// Пример теста в рамках TDD п.1
@Test
void addProductCreatesCartItem() {
    // given
    // создаем корзину
    String sessionId = UUID.randomUUID().toString();
    Cart cart = cartService.getOrCreateCart(null, sessionId);

    // создаем продукт
    Product product = createAndSaveProduct("Test-Product", BigDecimal.valueOf(10000.00));

    // when
    cartService.addProduct(cart.getId(), product.getId());

    // then
    List<CartItem> items = cartItemRepository.findByCartId(cart.getId());
    assertThat(items).hasSize(1);

    CartItem item = items.getFirst();
    assertThat(item.getProductId()).isEqualTo(product.getId());
    assertThat(item.getQuantity()).isEqualTo(1);
    assertThat(item.getUnitPrice().doubleValue())
            .isEqualTo(product.getPrice().doubleValue());
    assertThat(item.getProductName()).isEqualTo("Test-Product");
    assertThat(item.getProductSku()).isEqualTo("SKU-123");
}
````

Получается бизнес-логика была проверена на уровне БД и сервиса, это уже хорошо, тем более я сделал все с **_TestContainer_**, которая делает аналог реальной БД.
Я сразу решил проверить это в шаблонах и реализации контроллеров, и к моему удивлению все шаблоны с первого раза работали корректно 
т.е минимальная реализация корзины была готова.
TDD действительно ускоряет разработку, а не замедляет её как многие могут подумать. Ведь если сначала писать код, а потом делать тесты теряется вся суть тестов.
Как будто они нужны для галочки больше нежели как проверка корректности работы кода приложения.
А если присушиваться к TDD и стараться делать по этой методике, можно гораздо быстрее делать реализацию и уже не беспокоясь о написании тестов потом.

Далее потребовалось повторить написание рабочего кода по TDD, но уже с акцентом на логическую архитектуру, единый дизайн.  
_Код не должен следовать тестам, ни тесты не должны следовать коду._

Это задание было еще сложнее первого, потому что мыслить на высоком уровне абстракции не так просто.
Но для начала я решил написать некую спецификацию к модели Корзина (Cart), как она должна работать и
взаимодействовать с другими сущностями.
- Создание корзины (итог - пустая корзина без товаров)
- Добавление товара (итог - товар добавлен в корзину, кол-во > 0)
- Увеличение кол-ва товара (итог - товар добавлен аналогичный товар, кол-во = +1)
- Уменьшение кол-ва товара (итог - товар удален из корзины, кол-во = -1)
- Полное удаление товара (итог - данного типа товара нет)
- Очистка корзины (итога размер корзины 0 - пустая)
и т.д.
Конечно как предусловие, корзина должна существовать обязательно (проверка) в операциях добавления и удаления и т.д.

````java
// Пример какие получились тесты в рамках TDD п.3
@Test
void whenProductAddedToEmptyCart_cartContainsOneItemWithSnapshot() {
    // given
    String sessionId = UUID.randomUUID().toString();
    Cart cart = cartService.getOrCreateCart(null, sessionId);
    Product p = createAndSaveProduct("Drill", BigDecimal.valueOf(10000.00));

    // when — добавляем товар
    cartService.addProduct(cart.getId(), p.getId());

    // then — проверяем публичный API чтения (используя DTO)
    List<CartItemDto> items = cartService.getCartItems(cart.getId());

    assertThat(items).hasSize(1);
    CartItemDto item = items.getFirst();

    // проверяем только публичное поведение
    assertThat(item.getProductId()).isEqualTo(p.getId());
    assertThat(item.getQuantity()).isEqualTo(1);

    // snapshot - контракт
    assertThat(item.getTotalPrice()).isEqualByComparingTo(p.getPrice());
    assertThat(item.getProductName()).isEqualTo("Drill");
}
````
Требуется проверка логики сервиса, и не нужно лезть в репозиторий и смешивать всё.  
Вкратце в чем преимущество единого дизайна и спецификации:
1. Название отражает сценарий использования
2. Мы проверяем только публичный API (getCartItems)
3. Используем DTO как уровень абстракции 
4. Проверяем поведение, а не состояние
5. Дает устойчивость к изменениям  

Здесь конечно нужна практика, но прослеживаются улучшения в работе и постараюсь придерживаться TDD, 
спецификаций и единому дизайну и дальше.
Буду оттачивать полученные навыки на моём пет-проекте дальше.)